// Package platformapiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package platformapiv1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	KeyAuthScopes    = "keyAuth.Scopes"
)

// APIKeyCreate defines model for APIKeyCreate.
type APIKeyCreate struct {
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
}

// APIKeyResponse defines model for APIKeyResponse.
type APIKeyResponse struct {
	CreatedAt time.Time          `json:"createdAt"`
	ExpiresAt time.Time          `json:"expiresAt"`
	Id        openapi_types.UUID `json:"id"`
	RawToken  string             `json:"rawToken"`
}

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// FeatureFlag defines model for FeatureFlag.
type FeatureFlag struct {
	// Active Whether the feature flag is enabled or disabled
	Active    bool      `json:"active"`
	CreatedAt time.Time `json:"createdAt"`

	// Description A short description of the feature flag
	Description *string            `json:"description,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// Name The name of the feature flag
	Name      string             `json:"name"`
	OwnerId   openapi_types.UUID `json:"ownerId"`
	UpdatedAt time.Time          `json:"updatedAt"`
}

// FeatureFlagCreateRequest defines model for FeatureFlagCreateRequest.
type FeatureFlagCreateRequest struct {
	// Active Whether the feature flag is enabled or disabled
	Active bool `json:"active"`

	// Description A short description of the feature flag (optional)
	Description *string `json:"description,omitempty"`

	// Name The name of the feature flag
	Name string `json:"name"`
}

// FeatureFlagList defines model for FeatureFlagList.
type FeatureFlagList struct {
	FeatureFlags []FeatureFlag `json:"featureFlags"`
	Total        int           `json:"total"`
}

// FeatureFlagResponse defines model for FeatureFlagResponse.
type FeatureFlagResponse struct {
	// Active Whether the feature flag is enabled or disabled
	Active bool `json:"active"`

	// Description A short description of the feature flag
	Description string `json:"description"`

	// Name The name of the feature flag
	Name    string             `json:"name"`
	OwnerId openapi_types.UUID `json:"ownerId"`
}

// FeatureFlagToggleRequest defines model for FeatureFlagToggleRequest.
type FeatureFlagToggleRequest struct {
	// Active Indicates if the feature flag should be enabled (true) or disabled (false)
	Active bool `json:"active"`
}

// FeatureFlagUpdateRequest defines model for FeatureFlagUpdateRequest.
type FeatureFlagUpdateRequest struct {
	// Active Indicates if the feature flag is enabled (true) or disabled (false)
	Active bool `json:"active"`

	// Description An optional description of the feature flag
	Description *string `json:"description,omitempty"`

	// Name The name of the feature flag
	Name string `json:"name"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// Message defines model for Message.
type Message struct {
	Message string `json:"message"`
}

// RegistrationRequest defines model for RegistrationRequest.
type RegistrationRequest struct {
	Email           openapi_types.Email `json:"email"`
	Name            string              `json:"name"`
	Password        string              `json:"password"`
	PasswordConfirm string              `json:"passwordConfirm"`
}

// Token defines model for Token.
type Token struct {
	RefreshToken          string    `json:"refreshToken"`
	RefreshTokenExpiresAt time.Time `json:"refreshTokenExpiresAt"`
	Token                 string    `json:"token"`
	TokenExpiresAt        time.Time `json:"tokenExpiresAt"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time           `json:"createdAt"`
	Email     openapi_types.Email `json:"email"`
	Id        openapi_types.UUID  `json:"id"`
	Name      string              `json:"name"`
	UpdatedAt time.Time           `json:"updatedAt"`
}

// CreateAPIKeyJSONRequestBody defines body for CreateAPIKey for application/json ContentType.
type CreateAPIKeyJSONRequestBody = APIKeyCreate

// CreateFeatureFlagJSONRequestBody defines body for CreateFeatureFlag for application/json ContentType.
type CreateFeatureFlagJSONRequestBody = FeatureFlagCreateRequest

// UpdateFeatureFlagToggleJSONRequestBody defines body for UpdateFeatureFlagToggle for application/json ContentType.
type UpdateFeatureFlagToggleJSONRequestBody = FeatureFlagToggleRequest

// UpdateFeatureFlagJSONRequestBody defines body for UpdateFeatureFlag for application/json ContentType.
type UpdateFeatureFlagJSONRequestBody = FeatureFlagUpdateRequest

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginRequest

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody = RegistrationRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create API key
	// (POST /api-keys)
	CreateAPIKey(w http.ResponseWriter, r *http.Request)
	// Retrieve User ID
	// (GET /api-keys/user)
	GetUserByAPIKey(w http.ResponseWriter, r *http.Request)
	// Delete API key
	// (DELETE /api-keys/{id})
	DeleteAPIKey(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Retrieve all feature flags
	// (GET /feature-flags)
	ListFeatureFlags(w http.ResponseWriter, r *http.Request)
	// Create a new feature flag
	// (POST /feature-flags)
	CreateFeatureFlag(w http.ResponseWriter, r *http.Request)
	// Delete a specific feature flag by ID
	// (DELETE /feature-flags/{id})
	DeleteFeatureFlag(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Retrieve a specific feature flag by ID
	// (GET /feature-flags/{id})
	GetFeatureFlag(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Toggle a feature flag on or off
	// (PATCH /feature-flags/{id})
	UpdateFeatureFlagToggle(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Update a specific feature flag by ID
	// (PUT /feature-flags/{id})
	UpdateFeatureFlag(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Retrieve a specific feature flag by User ID and Flag Name
	// (GET /feature-flags/{userId}/{flagName})
	GetFeatureFlagByUserAndName(w http.ResponseWriter, r *http.Request, userId openapi_types.UUID, flagName string)
	// Login
	// (POST /login)
	Login(w http.ResponseWriter, r *http.Request)
	// Register
	// (POST /register)
	Register(w http.ResponseWriter, r *http.Request)
	// WebSocket connection
	// (GET /ws)
	WebsocketHandler(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Create API key
// (POST /api-keys)
func (_ Unimplemented) CreateAPIKey(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve User ID
// (GET /api-keys/user)
func (_ Unimplemented) GetUserByAPIKey(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete API key
// (DELETE /api-keys/{id})
func (_ Unimplemented) DeleteAPIKey(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve all feature flags
// (GET /feature-flags)
func (_ Unimplemented) ListFeatureFlags(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new feature flag
// (POST /feature-flags)
func (_ Unimplemented) CreateFeatureFlag(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific feature flag by ID
// (DELETE /feature-flags/{id})
func (_ Unimplemented) DeleteFeatureFlag(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve a specific feature flag by ID
// (GET /feature-flags/{id})
func (_ Unimplemented) GetFeatureFlag(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Toggle a feature flag on or off
// (PATCH /feature-flags/{id})
func (_ Unimplemented) UpdateFeatureFlagToggle(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific feature flag by ID
// (PUT /feature-flags/{id})
func (_ Unimplemented) UpdateFeatureFlag(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve a specific feature flag by User ID and Flag Name
// (GET /feature-flags/{userId}/{flagName})
func (_ Unimplemented) GetFeatureFlagByUserAndName(w http.ResponseWriter, r *http.Request, userId openapi_types.UUID, flagName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Login
// (POST /login)
func (_ Unimplemented) Login(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register
// (POST /register)
func (_ Unimplemented) Register(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// WebSocket connection
// (GET /ws)
func (_ Unimplemented) WebsocketHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateAPIKey operation middleware
func (siw *ServerInterfaceWrapper) CreateAPIKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAPIKey(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetUserByAPIKey operation middleware
func (siw *ServerInterfaceWrapper) GetUserByAPIKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, KeyAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserByAPIKey(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAPIKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPIKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAPIKey(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListFeatureFlags operation middleware
func (siw *ServerInterfaceWrapper) ListFeatureFlags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFeatureFlags(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateFeatureFlag operation middleware
func (siw *ServerInterfaceWrapper) CreateFeatureFlag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateFeatureFlag(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteFeatureFlag operation middleware
func (siw *ServerInterfaceWrapper) DeleteFeatureFlag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFeatureFlag(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFeatureFlag operation middleware
func (siw *ServerInterfaceWrapper) GetFeatureFlag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFeatureFlag(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateFeatureFlagToggle operation middleware
func (siw *ServerInterfaceWrapper) UpdateFeatureFlagToggle(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFeatureFlagToggle(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateFeatureFlag operation middleware
func (siw *ServerInterfaceWrapper) UpdateFeatureFlag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFeatureFlag(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFeatureFlagByUserAndName operation middleware
func (siw *ServerInterfaceWrapper) GetFeatureFlagByUserAndName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", chi.URLParam(r, "userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	// ------------- Path parameter "flagName" -------------
	var flagName string

	err = runtime.BindStyledParameterWithOptions("simple", "flagName", chi.URLParam(r, "flagName"), &flagName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flagName", Err: err})
		return
	}

	ctx = context.WithValue(ctx, KeyAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFeatureFlagByUserAndName(w, r, userId, flagName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Register operation middleware
func (siw *ServerInterfaceWrapper) Register(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Register(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// WebsocketHandler operation middleware
func (siw *ServerInterfaceWrapper) WebsocketHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WebsocketHandler(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api-keys", wrapper.CreateAPIKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api-keys/user", wrapper.GetUserByAPIKey)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api-keys/{id}", wrapper.DeleteAPIKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/feature-flags", wrapper.ListFeatureFlags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/feature-flags", wrapper.CreateFeatureFlag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/feature-flags/{id}", wrapper.DeleteFeatureFlag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/feature-flags/{id}", wrapper.GetFeatureFlag)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/feature-flags/{id}", wrapper.UpdateFeatureFlagToggle)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/feature-flags/{id}", wrapper.UpdateFeatureFlag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/feature-flags/{userId}/{flagName}", wrapper.GetFeatureFlagByUserAndName)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/login", wrapper.Login)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/register", wrapper.Register)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ws", wrapper.WebsocketHandler)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
